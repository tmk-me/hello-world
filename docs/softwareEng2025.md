---
layout: page
title: "software Eng. lecture note"
permalink: /docs/softwareEng2025
---
# ソフトウェア工学で学んだ内容のまとめ
## ソフトウェア工学1
　第1回の講義では、このソフトウェア工学の到達目標を確認した。この講義の到達目標はソフトウェア・エンジニアリングの基礎知識の理解および実務的なスキルの習得である。また狙いとしてソフトウェア工学の知見を考える機会提供をする狙いがある。ソフトウェア工学の難しいところはソフトウェア開発に携わった経験がないとイメージが沸かないこと、知見を理解しても実践することが難しいこと、個々人のソフトウェア工学の知識だけでは不十分でチーム全体で共有する必要があることなどが挙げられる。
## ソフトウェア工学2
　第2回の講義では「ソフトウェア工学」とは何かについて学んだ。ソフトウェアの定義は実行されることによって必要な特性、機能、性能を提供する命令語群,プログラムが適切に情報を扱うことを可能とするデータ構造, プログラムの操作や使用法を記述した情報とされている。またソフトウェア工学は「品質」,「コスト」,「納期」の最適なバランスを実現するための手法・方法論のことを指す。近年ではIT産業が大規模化し、また複雑になっていること、IT人材が不足していること、ライフライン・インフラストラクチャーの一部として、不測の事態に対応した事業やサービスの継続が求められること等からソフトウェア工学の必要性が増してきている。
## ソフトウェア工学3
　第3回の講義ではソフトウェアライフサイクルについて学んだ。ソフトウェアライフサイクルはソフトウェアの誕生からソフトウェアの開発・運用、ソフトウェアの廃止までの一連の流れを指す。ソフトウェアの誕生のセクションではシステム上の要求を具現化するための企画・計画を行い、その上で要件定義を行う。要件定義とは実現する機能・実現しない機能を明確に定義することを指す。要件定義を行った後は要件定義書から設計書を作成し、また設計書に従ってシステム構築を行う。。ソフトウェアの開発・運用のセクションでは設計されたソフトウェアのテスト・デバックを行ったり、稼働後のデータをプロアクティブに活用するための運用・保守を行ったりする。
## ソフトウェア工学4
　第4回講義ではプロジェクト、ソフトウェア分析、開発プロセスについて学んだ。
プロジェクトとは有期性、独自性を持つ仕事のことを指す。プロジェクトに関する重要語句としてフォアキャスティング、バックキャスティングがある。フォアキャスティングはインプット視点でどれだけ仕事をしたのかを指し、今の立ち位置から順に目標に進んでいく方法である。バックキャスティングはアウトプット視点で何を成し遂げたかを指し、定めた目標に向けて何が必要かを計画し達成に向かうものを指す。
ソフトウェア分析はソフトウェアを見える化するための手法である。例としてソフトウェアの物量に関する分析や実行性能に関する分析、開発工数に関する分析などがある。ソフトウェアの評価は主に価値を測ることによって行われ、コードの物量（ステップ数）などがそれに該当する。またソフトウェアの品質を測る方法として、バグ発生率を調べる方法や、ファンクションポイント法などがある。
開発プロセスは主にウォーターフォール開発プロセスとアジャイルプロセスに分類される。ウォーターフォール開発は進捗管理が容易で成果物が明確であるが後工程にしわ寄せが集中するリスクがあるという特長を持つ。アジャイル開発は反復型開発プロセスと言われ、ソフトウェアを機能分割し、これを「反復」と呼ぶ単位で管理する積み上げ方式である。部分的に完成させていくので、顧客の要求を取り入れやすいというメリットがある一方、分割のための作業や管理義務が増えるというデメリットがある。どちらの開発手法も一長一短があり、場面・要求に沿って使い分けることが重要である。
## ソフトウェア工学5,6
　第5,6回講義ではWBS(Work Breakdown Structure)について学んだ。WBSはプロジェクト目標を達成し、必要な要素成果物を生成するために、プロジェクトチームが実行する作業を、要素成果物を主体に階層的に要素分解したものを指す。WBSを用いるメリットとしてスコープが明確になること、作業を洗い出すことが出来ること、全体管理と作業計画が明確化されることなどがある。
## ソフトウェア工学7
　第7回講義ではコーディングについて学んだ。コードは書くことよりも読まれることの方が多いため、ソフトウェア開発においては読みやすいコードを書くことは必須である。授業ではPythonのPEP8を学び、1行の長さやコードのレイアウト、スペース、改行などについて気を付けた。またflake8というチェックツールを用いることでPEP8に則ったコードを作成できているか確認した。
## ソフトウェア工学8,9
第8,9回講義ではバージョン管理について学んだ。バージョン管理はファイルが「誰が」「いつ」「どのように」変更したかを管理するものであり、これらの情報が管理されていれば多数のメンバーとも共同でコード開発が出来る。バージョン管理には集中管理型と分散管理型がある。gitは分散管理型のバージョン管理システムである。もともとはオープンソースソフトウェア管理のためのソフトウェアである。gitを利用することで変更りいれ気が残ったり、変更した箇所に戻ることが出来たり、他人と共同編集出来たりする利点がある。gitが管理するプロジェクタのフォルダのことをレポジトリと言い、個々のプロジェクト実行環境のことをローカルレポジトリ、共有の管理場所をリモートレポジトリという。作業ツリーで編集した内容をステージングエリアに追加しローカルリポジトリにコミットすることで変更内容を履歴として正式に保存することができる。ローカルリポジトリでコミットされた内容はリモートレポジトリへ反映させることが出来る。またリモートレポジトリにある内容をローカルリポジトリに反映することもできる。
## ソフトウェア工学10
第10回講義ではLearning git branchingを用いてgitの仕組みについて学んだ。gitで良く用いられるcommitやbranch,checkout,mergeなどについて視覚的に学ぶことが出来た。またgitコマンドについても学んだ。特にステージングエリアへの追加を行うgit add,変更をアップロードするgit push,コミットへの実行を行うgit commitは多く利用した。
## ソフトウェア工学11
第11回講義ではGihubについて学んだ。githubはリモートレポジトリのホスティングサービスの一つであり、またオープンソースソフトウェアの主要なポータルサイトである。githubを利用することでいくつでもforkできたり、レポジトリに関する問題・課題・バグ・機能追加や質問などを挙げるための機能を利用できたりする。
## ソフトウェア工学12
第12回講義ではCI/CDについて学んだ。Continuous Integration (CI)はコード変更を共有リポジトリに頻繁に統合するプロセスであり、自動テストとビルドを定期的に実行し、バグの早期発見と修正を可能にしたりCIの自動化により開発のスムーズな進行を促進したりすることが出来る。ContinuousDelivery (CD)はコード変更をテスト環境や本番環境に自動的にデプロイするプロセスであり、自動デプロイメントを組み込み、手動操作によるデプロイの必要性を排除している。また、CDによりユーザーフィードバックを迅速に反映可能である。GitHub Actionsを使用したCI/CDは以下のとおりである。
1,ワークフローの定義: YAMLファイルで定義し、 .github/workflows/ディレクトリに配置する。イベント、ジョブ、ステップで構成されている。
2 トリガー:プッシュ、プルリクエスト、スケジュールなど様々なイベントでワークフローを起動可能
3 ジョブとステップ:ジョブは並列実行が可能である。ステップでは、シェルコマンドの実行やアクションの使用が可能である。
4 アクション: 再利用可能なワークフローの構成要素である。コミュニティが作成したアクションも利用可能である。
5 ランナー:GitHub提供のホステッドランナーまたはセルフホステッドランナーを使用可能である。
課題ではCIでflake8で適用し、test.pyにおけるテストを行った。
## ソフトウェア工学13
第13回講義ではCI/CDの実践を行った。Github PagesではGithubにあるリモートレポジトリの内容をwebpageとして公開することが出来る。HP更改はCI/CDにより自動化され、またjekyllを使用することでmarkdownファイルを自動でhtml化することが出来る。課題では作成したHPで本講義で学んだことのまとめを書き、ホームページを公開した。
